
consider making override option for drawsocket.send
so it could be cleaner to switch between browser and electron
(overriding to ipcRenderer.send)

# short term to do
- update from gui doens't work with stave because the getObjViewContext function doesn't go all the way to the svg elment,
    however, this also makes me wonder if maybe staves shouldn't be redrawn based on the info ... 
        but that's not right, of course it should, for example, you might have a 5 line staff and want to change the clef, 
            that could be an attribute of the 5 line stave


- add expression composition interface



print to pdf https://stackoverflow.com/questions/43015044/electron-printtopdf-from-browserwindow



user scripts

on new object click
    symbolistEvent creates new data object and generates view from data

    sequece could be:
    - UI event, sends new click notice and class name to controller
        controller creates data from symbol def, data creates view
        - then def calls custom UI to edit the object
            do we have a data from view?
                newFromClick, mappings, transform do this
                better to make a function for that?
    or
    - UI event, 

on palette selection:
1) enters create symbol UI, sets limits and range of possible creation,
    for example, quantized to scale degrees etc.

on selection:
1) enter symbol UI, which sets possible types of transformation (translation mode)

after selection
1) possibility to go into edit mode, similar to creation mode


so for general selection, we can keep the drag area rect
in illustrator there are different tools that can perform the same types of actions on the objects
in symbolist right now you need to hold down the cmd key which is like selecting the symbol palette icon to create the symbol, rather than selecting -- maybe this is still an interesting why to go...

sine we may sill want to create symbols by drawing rather than importing them.

TO DO:
revise symbols to use modes to customize the UI

translation should not necesarily be a built in edit UI, for example maybe translation means somethind different in different contexts. the idea from before was that the stave would define a concept of organization of it's symbols, be it in time, or some other aspect, like space



key thing to remember: view and model use the same ids, so the "data_context" will have the same id as the "view_context"
therefore, a graphic object can be interpreted into data via mapping (in the controller still probably) and use the view_context as the parent
newFromClick will still get used

- set stave as context
- icons appear
- select icon
- ghost position preview appears limited by stave -- but calcuated in the symbol? how does the symbol know about the parent context?


previously i was trying to stick with the MVC pattern, and work with the idea that the view objects would be really updated by the def, since it might override the view update -- and i stil think that is interesting, but now since we will have scripts read by the view as well, i think it makes more sense to have the view apply the transform (which it is already doing? is that a dummy object?) and then the def can update the model from the upated view object, and will still have the opiton to limit or change the data based on that , so the view should still be updated after the data is updated.


page.staves = [ staveid, staveid, ... ]

stave.events = [ eventid, eventid, ... ]


a difference between the drawsocket and symbolist_renderer format of objects is that drawsocket uses the 'new' tag 
maybe we should change that? maybe not... new makes drawsocket remove the old object and overwrite a new one in its place.

symbolist_renderer sends back a "type" tag instead of new... 



now mapping is all in browser, to from data graphics
then sending out changes, and additions, which can go to the lookup system

would be cool for thursday to :
create meta process that creates other data (like tempo curver or clustering)
ceate symbol with rotating line for azimuth


top level element is identified by the class "symbol" and all dataset information should be in this object
best is if all symbols are wrapped in <g> tags, so that GUI elements can be contained inside of them

/**
 * view container model (stave/page/etc)
 * 
 * svg:
 * <g class='className symbol container' data-time="0.1" data-duration="1" >
 *      <g class='className display'></g>
 *      <g class='className contents'></g>
 * </g>
 * 
 * html:
 * <div class='className symbol container'>
 *      <div class='className display'></div>
 *      <div class='className contents'></div>
 * </div>
 * 
 * regular objects can be any node type
 * usually they will be in a container
 * 
 * <g class"className symbol" data-time="0.1" data-duration="1">
 *     <circle .... />
 * </g>
 * 
 * 
 * sent to browser using drawsocket format
 * 
 */


 for rotation, rectangles are special becuase they are defined by width and height, which means that we can't apply the rotation matrix to the object parameters, but need to use a transform, that means that the mapping has to use the transform also, which in turn means that the preview translation before we apply the values to the real object needs to be handled slightly differently. 

 the basic idea is that you apply the translation to the top group and then update the object values on mouse up, or cancel if you press escape

- work on reducing the amount that the renderer is doing
- clean up symbolist_event code (remove all of it?)
- rename controllers?
    "ui handler" ?
        ui mapping scripts
    "lookup handler" ?
        lookup scripts (could also map)

 - separate lookup scripts
 - create proof of concept for lookup scripts

 - proof of concept for score symbols
    - frame notation as before 
    - point with arrows pointing to direction, 
        could also be several points/directions, using mc.granubuf style encoding the postion with the grains
    - work on granular synth notation
    - later modular synth notation
        modular synth seems more complicated maybe

    - alternative types of scores, like what?
    - evolving score, that is defined by a weighted map
        the map produces data objects, which are then notated

    - data visualisation, using max or other process to create data, could be sensors also
        how many points can the system handle?

- need scrolling to work
    done -- mostly
    
- for now  we can just use a single stave?
    or create page object that groups container staves, and usually acts to show the synchronization between them

- add init ping from browser (or in did-load) to send data from server side

for lookup 
// start at top level and descend through container/contents id lists
// will need to identify containers in the model
    maybe keep a separate array of container id's

// will also need the sorting mechanism
    for finding the right container if the user doesn't know or include an id when sending data in via UDP

symbols should define the sorting mechanism that sorts themselves, not their children (afaict)
better if each type defines the method for sorting that type




    /**
     * if there is a parent id already known we can speed this up a bit and just lookup by id
     * without having to find which container instance is the right one
     * 
     * on the other hand, we don't always actually need to know the container instance,
     * e.g. in cases of continued staves in new systems. In these cases, it's even better
     * not to use the container info to lookup the event symbol info
     * 
     * but if the output is dependent on information in the container instance, then the id 
     * will be needed to lookup the value. 
     * 
     * So, what we can do here is check if the parent is an ID, and if it is, get the classType?
     * 
     * no: what ever the parent is will be the way that the system tries to find the symbol
     * so if the parent is an id, the system will lookup by id and get the value at the right time
     * based on the lookup script. 
     * 
     * 
     */


structure idea:
staves are one object, that visually separate chunks of time into segments to fit the formatting of a page. this is great for printing and reading, however is not directly part of the playback information of the score.

therefore the structure of the score is that there is one container (stave) for a given set of points.

in other types of scores, maybe there could be some kind of structural meaning for the segmentation of the events into separate blocks. in this case the container becomes a symbol (that may or may not be a container of other events)

what this means is that "staves" in the palette create a single structure that multiple events can exist inside. if staves allow you to make multiple instances, they are actaully connected, since they are container objects.

maybe both types of objects can be top level, and we don't need the separation of the stave and symbol in the pallette, but for now i'll try this approach